% Proposed solution

\chapter{Implementation} \label{ch:impl}
This chapter provides a detailed explanation of how the project was implemented from the environment set-ups to the automation and execution of that automation, outlining the practises, techniques, and steps taken to bring the project to completion.
Metropolia University of Applied Sciences provided a LORIX One gateway, micro\gls{sd} card with ChirpStack Gateway \gls{os} image installed to it, a spare micro\gls{sd} card and a \gls{lora} end device that is used by the students in the courses the project is implemented for.

The source code for the implementation can be found from the appendix.
Sensitive information in variables, like password, is replaced with dummy versions.

\section{Setting up LORIX One}
The LORIX One gateway is used to establish the connection between the Chirpstack Network Server and the \gls{lora} devices.
The gateway came together with an micro\gls{sd} card where the ChirpStack Gateway \gls{os} image was installed already.
The LORIX One has a slot for the micro\gls{sd} card inside where it was put.
After that the LORIX One was connected to a router to get ethernet access and to an outlet to get power.
When the gateway is powered it starts the boot immediately meaning in this case the ChirpStack Gateway \gls{os} image.

\section{Setting up Chirpstack}
When the connection is stable in the LORIX One gateway and its status led blinks on a heartbeat mode the \gls{os} installation can be started.
The \gls{os} is booted each time it is connected to a power supply and the user needs to login using \gls{ssh}.
The login can be done using ssh command as seen in figure on a command prompt.
The command requires the username and the \gls{ip} address for the server as seen in \todo{FIGURE REF}.
Username was provided from the school and the \gls{ip} address was verified from the router's connected devices.

\todo{CODE FIGURE ssh user@lorixip}

\todo{When the user has logged in successfully a message seen in figure is shown.}

\todo{FIGURE OF CHIRPSTACK.IO MESSAGE FROM COMMAND PROMPT}


As mentioned earlier the micro\gls{sd} card was provided with the Chirpstack \gls{os} and also with the needed credentials to log in.
The data the card contained the latest settings that Metropolia University of Applied Sciences uses and no new configurations were needed.
The command prompt was closed with exit command.

\section{Creating Excel file for the end devices}
Excel file was selected for storing the information about the application name and it's details and all the devices that it should have in it.
The decision to utilize an Excel file was selected due to a accessibility of a pre-existing library called RPA.Excel.Files in Robot Framework.

The excel file layout was designed so that each sheet the file includes would be named after the application name that the sheet contains.

When a sheet is opened it has 3 headers focusing on the application in the first row.
Those headers are called Application name, Application description and Service profile.
On the second row under that the columns have that information accordingly so that the data can be fetched by using the headers.

Row 4 contains headers for adding a \gls{lora} device to the application.
Those headers are called Device name, Device description, Device \gls{eui}, Device-profile and Application key.
Under those headers the user adds the device information correspondingly.

The Device \gls{eui} consists of 16 digits and/ or characters that can be given with 3 different forms, all written together, or with spaces, or colons as separators.
The parsing of colons and spaces is handled by ChirpStack.
The restrictions for the \gls{eui} code are, that it can not include special characters in any form, as they are ignored by the ChirpStack, when the \gls{eui} is given to the corresponding field and a lack of correct amount of accepted digits and/ or characters results to an error when the device is tried to be added.

The Excel file filling is fully manual and left to the educator to fill, but for this project two mock up sheets were created to test that the functionality works correctly.

\section{Creating automation}
This section will give an overview of how the automation was created for the project.
The automation was done using Robot framework in Visual Studio Code source code editor as it provides the possibility to implement Robot Framework and Robocorp extensions that were used.

First step to start the automation was to build up the project structure for the ease of maintenance.
The project directory contains two main folders called automation and resources alongside with .gitignore file and requirements.txt file.
Automation folder contains the two robot files used for the automation, \_\_init\_\_.robot and automation.robot.
Resources folder is used in this project to store the variables used in the project.
All the required packages and libraries are included to the requirements.txt file.

\subsection{variables.py}
Variables.py is a python file where all the variables in are stored to easily modify them if needed from one place.
In this project the file is imported to the test suites which uses those variables for setting up the test suite for log in.

The variables.py file includes a list of variables that are used mostly in the suite setup but also in the process automation.

A mockup version of the file is provided in the appendix to see what kind of formats were used.

\subsection{Suite Setup and Suite Teardown}
In this project Suite setup was selected to be utilized to improve unnecessary repeat of steps to be taken and to verify the pre-steps are functioning correctly before the tasks are run.
The suite setup was utilized to a suite initialization file called \_\_init\_\_.robot file which is run once and before automation folder's files are executed.

The suite setup task that was implemented is called Login to ChirpStack.
The task opens the browser with the browser that was specified in the variables.py file.
For running the automation with a window where the user can see the progress while it runs the headless argument was set to false.
When the browser is opened the next keyword takes the ChirpStack server's \gls{ip} address for the login page that was initialized in the variables.py file.
The code then proceeds to fill the text fields for username and password also with values that were initialized in the variables.py file.
When the login credentials have been filled the task clicks the login button, that is identified by its css value.
The task then uses keywords to save the updated page's \gls{url} to a variable and then compares it to the expected \gls{url}.

When the automation file is executed the logs show if the setup passed alongside with the tasks.
If the suite setup fails the tasks will also be set to fail status.

SUITE TEARDOWN

\subsection{Process automation}
The automation.robot file consist of tasks that were used for automating the creation of an application and of adding devices to that application.

The file has two tasks, Create Application and Add devices. VERIFY FROM SOURCE CODE
For utilizing these tasks 3 Robot Framework libraries were imported in the settings section: Browser, Dialogs and RPA.Excel.Files.

Create Application \todo{KEYWORD} is the first one to be run after the suite setup from the automation.robot file, when it is being executed.
The \todo{KEYWORD} clicks the identified create button on top of the application page's layout.
After that it opens the Excel file with the name that was provided in the variables.py file.
When the Excel workbook is open, the user is asked for the correct sheet, which is named after the desired application. \todo{VERIFY SOURCE CODE IS ACCURATE}
The worksheet is then read to a table format into a variable.
The table is then used to save the application name to a variable.
That name is then typed to the correct text field called Application name.
Next keyword saves the application description to a variable and similarly that is then added to the Application description text field on the web-interface.
Lastly the service-profile is fetched to a new variable and then service-profile's dropdown list menu item is clicked on the page and when the list opens, the corresponding service-profile is selected by clicking it.
When all the required information is filled the task clicks the Create application button and closes the Excel file.

When the Create application task is run the execution moves to the Add devices task.
Add devices task requires application name as an argument.
It also uses a keyword called Add One Device, which takes a device as an argument. That keywords functioning is described after this task.
Add devices task starts from the web-interface's Applications layout which is visible when the user is logged in. 
The task compares if the application name given in the argument is found from the list and opens it, and if it is not, it starts to create a new one with the Create Application \todo{KEYWORD}.
When the application is open the Excel file is opened from the worksheet that has a corresponding name to the application.
The work sheet is then saved to a variable as a table of the devices from the worksheet.
The devices that are listed to the worksheet start from the 4th row and therefor the table's first index is set there.
The table variable is then logged so the list can be verified when the automation.robot file's execution ends and the logs can be checked.
After that the Excel file is closed and a for loop starts to run.
The for loop goes through all the devices on the table and adds them individually with the Add One Device keyword.

Add One Device key was created to cut the keywords that the task requires to smaller sections that increases the readability and the detection of possible issues.
As mentioned earlier the Add One Device requires a device variable as a argument.
The keyword starts running on the web-interface's Application layout that is seen when a selected application is open.
That is the result view when the Create Application task is successfully run.
Add One Device keyword  clicks the Create button from the web-interface and proceeds to fill Device name, Device description and Device \gls{eui} fields with values that are got from the device variable.
After that, the Create device button is clicked and the keyword waits that Wait for Elements State keyword to find the Application key field and fills that with corresponding value from device variable and then again waits until Set device keys button is visible until it is, and can be clicked.


\cite{chirpstack:getting_started}
\cite{robot_framwework_user_guide:suite_setup_and_teardown}
\clearpage %force the next chapter to start on a new page. Keep that as the last line of your chapter!
